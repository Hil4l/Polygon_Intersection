//Author: Jean-Philippe Kleijkers

// Graham's Scan algorithm is used to find the convex hull

var points = [];
var segments = [];
var convexHulls = [];
var ANCHOR;
var pointTocmp = null;
var DOTSIZE = 6;
var allowAddingPoints = true; //flag to avoid points to be placed
const epsilon = 1e-6;

var maxX = 600;
var maxY = 600;
var minX = 0;
var minY = 0;
var STOP = false;
//var to enable the drawing of each step of the algorithm
var drawAB = false;
var drawTangeant = false;
var drawAXBY = false;
var drawLSet = false;
var drawViWi = false;

var pauseWhenCollide = false;
var collisionHappened = false;


//function that calculates the speed of each polygon after the collision
//the collision is elastic
//the function has been generated by AI:Chat GPT 
function calculateSpeedAfterCollision(P, Q) {
  let m1, m2, v1x, v1y, v2x, v2y;
  m1 = P.area;
  m2 = Q.area;
  v1x = P.speedx;
  v1y = P.speedy;

  v2x = Q.speedx;
  v2y = Q.speedy;

  const vxRel = v1x - v2x;
  const vyRel = v1y - v2y;

  const angle = Math.atan2(vyRel, vxRel);
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);

  const v1Parallele = v1x * cosAngle + v1y * sinAngle;
  const v2Parallele = v2x * cosAngle + v2y * sinAngle;

  const v1Perp = -v1x * sinAngle + v1y * cosAngle;
  const v2Perp = -v2x * sinAngle + v2y * cosAngle;

  const v1ParallelePrime =
    ((m1 - m2) * v1Parallele + 2 * m2 * v2Parallele) / (m1 + m2);
  const v2ParallelePrime =
    ((m2 - m1) * v2Parallele + 2 * m1 * v1Parallele) / (m1 + m2);

  // Reconstruire les composantes en x et y après la collision
  const v1xPrime = v1ParallelePrime * cosAngle - v1Perp * sinAngle;
  const v1yPrime = v1ParallelePrime * sinAngle + v1Perp * cosAngle;
  const v2xPrime = v2ParallelePrime * cosAngle - v2Perp * sinAngle;
  const v2yPrime = v2ParallelePrime * sinAngle + v2Perp * cosAngle;

  // Mettre à jour les vitesses des particules
  P.setSpeed(v1xPrime, v1yPrime);
  Q.setSpeed(v2xPrime, v2yPrime);
}


//used to sort the points by their x coordinates
function comparePoints(pointA, pointB) {
  if (pointA.x < pointB.x) {
    return -1;
  } else {
    if (pointA.x === pointB.x && pointA.y < pointB.y) {
      return -1;
    }
    return 1;
  }
}

//Function that calculates the oriented angle between two vectors P1P and Ptan
//Function generated by AI:Chat GPT
function calculateOrientedAngle(P, P1, tan) {
  const u = { x: P1.x - P.x, y: P1.y - P.y };
  const v = { x: tan.x - P.x, y: tan.y - P.y };

  const dotProduct = u.x * v.x + u.y * v.y;

  const crossProduct = u.x * v.y - u.y * v.x;

  const angle = Math.atan2(crossProduct, dotProduct);

  return angle >= 0 ? angle : angle + 2 * Math.PI;
}
//used to sort the points by the angle they make with the ANCHOR
// of the Graham's Scan algorithm.
function comparePointsAngle(pointA, pointB) {
  var angleA = Math.atan2(pointA.y - ANCHOR.y, pointA.x - ANCHOR.x);
  var angleB = Math.atan2(pointB.y - ANCHOR.y, pointB.x - ANCHOR.x);
  if (pointA == ANCHOR) {
    return -1;
  }
  if (pointB == ANCHOR) {
    return 0;
  }
  if (angleB <= angleA) {
    return -1;
  }
  return 0;
}
//generic binary search
function binarySearch(a, b, compF) {
  while (a <= b) {
    let mid = Math.floor((a + b) / 2);
    if (compF(mid)) {
      a = mid + 1;
    } else {
      b = mid - 1;
    }
  }
  return b;
}


// calculates  the points of intersection between two lines
function getIntersectionPoint(L1, L2) {
  let a1 = L1.a;
  let b1 = L1.b;
  let c1 = L1.c;
  let a2 = L2.a;
  let b2 = L2.b;
  let c2 = L2.c;

  let denomX = a1 * b2 - a2 * b1;
  let denomY = a1 * b2 - a2 * b1;
  if (denomX == 0 || denomY == 0) {
    throw new Error("no intersection");
  }
  let x = (b2 * c1 - b1 * c2) / (a1 * b2 - a2 * b1);

  let y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);
  return new Point(-x, y);
}

// return the determinant to know the orientation of a dot compared to a segment
function orientationDET(segment, point) {
  var mat = new Matrix2X2(
    segment.b.x - segment.a.x,
    point.x - segment.a.x,
    segment.b.y - segment.a.y,
    point.y - segment.a.y
  );
  return mat.determinant();
}


function createRandomConvexPolygon(x, y, radius, maxPoints) {
  let rPoints = [];
  for (let i = 0; i < maxPoints; i++) {
    offsetX = Math.random() * radius;
    offsetY = Math.random() * radius;
    if (Math.random() > 0.5) {
      offsetX *= -1;
    }
    if (Math.random() > 0.5) {
      offsetY *= -1;
    }
    rPoints.push(new Point(x + offsetX, y + offsetY));
  }
  return new ConvexHull(rPoints);
}
function createCircularConvexPolygon(x, y, radius, maxPoints) {
  let rPoints = [];
  for (let i = 0; i < maxPoints; i++) {
    let angle = (2 * Math.PI * i) / maxPoints;
    let offsetX = Math.cos(angle) * radius;
    let offsetY = Math.sin(angle) * radius;
    rPoints.push(new Point(x + offsetX, y + offsetY));
  }
  return new ConvexHull(rPoints);
}

function createApproximatedCircularConvexPolygon(x, y, radius, maxPoints) {
  let rPoints = [];
  for (let i = 0; i < maxPoints; i++) {
    let angle = (2 * Math.PI * i + Math.random()) / maxPoints;
    let offsetX = Math.cos(angle) * radius;
    let offsetY = Math.sin(angle) * radius;
    offsetX += Math.random() * 10;
    offsetY += Math.random() * 10;
    rPoints.push(new Point(x + offsetX, y + offsetY));
  }
  return new ConvexHull(rPoints);
}

function createRectangularConvexPolygon(x, y, width, height) {
  let rPoints = [];
  rPoints.push(new Point(x, y));
  rPoints.push(new Point(x + width, y));
  rPoints.push(new Point(x + width, y + height));
  rPoints.push(new Point(x, y + height));
  return new ConvexHull(rPoints);
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  fill("black");
  textSize(40);
  height = 20;
  button = createButton("STOP");
  button.position(30, height);
  button.mousePressed(stopSim);

  button1 = createButton("Pencils");
  button1.position(80, height);
  button1.mousePressed(toDrawTang);

  button2 = createButton("lineAB");
  button2.position(30, height * 2);
  button2.mousePressed(toDrawLineAB);

  button3 = createButton("L set");
  button3.position(80, height * 2);
  button3.mousePressed(toDrawLset);

  button4 = createButton("Vi Wi");
  button4.position(80, height * 3);
  button4.mousePressed(toDrawViWi);

  button5 = createButton("AYBX");
  button5.position(30, height * 3);
  button5.mousePressed(toDrawAXYB);

  button6 = createButton("Pause When Collision");
  button6.position(30, height * 4);
  button6.mousePressed(pauseWhenCollision);

  button7 = createButton("Reset");
  button7.position(30, height * 5);
  button7.mousePressed(reset);


  reset();
}

function stopSim() {
  STOP = !STOP;
}
function toDrawTang() {
  drawTangeant = !drawTangeant;
}
function toDrawLineAB() {
  drawAB = !drawAB;
}
function toDrawAXYB() {
  drawAXBY = !drawAXBY;
}
function toDrawViWi() {
  drawViWi = !drawViWi;
}
function toDrawLset() {
  drawLSet = !drawLSet;
}
function pauseWhenCollision() {
  pauseWhenCollide = !pauseWhenCollide;
}

function reset() {
  convexHulls = [];
  let randomChoix = Math.floor(Math.random() * 3);
  if (randomChoix == 0) {
    convexHulls.push(createCircularConvexPolygon(100, 200, 50 + 50 * Math.random(), 5 + Math.random() * 60));
  } else if (randomChoix == 1) {
    convexHulls.push(createApproximatedCircularConvexPolygon(100, 200, 50 + 50 * Math.random(), 5 + Math.random() * 60));
  } else {
    convexHulls.push(createRandomConvexPolygon2(100, 200, 200, 30 + 50 * Math.random(), 30 + 50 * Math.random()));
  }
  convexHulls[0].cmName = "p";
  convexHulls[0].setSpeed(0.3 + Math.random() * 2, Math.random() * 2 + 0.3);

  randomChoix = Math.floor(Math.random() * 3);
  if (randomChoix == 0) {
    convexHulls.push(createCircularConvexPolygon(400, 350, 50 + 50 * Math.random(), 5 + Math.random() * 60));
  } else if (randomChoix == 1) {
    convexHulls.push(createApproximatedCircularConvexPolygon(400, 350, 50 + 50 * Math.random(), 5 + Math.random() * 60));
  } else {
    convexHulls.push(createRandomConvexPolygon2(400, 350, 200, 30 + 50 * Math.random(), 30 + 50 * Math.random()));
  }
  convexHulls[1].cmName = "q";
  convexHulls[1].setSpeed(-1 * Math.random() * 2 - 0.3, -1 * Math.random() * 2 - 0.3);
}

//function that calculates the size of the Lset depending on the pivtot and the edges hit by the tangeants
//P is a polygone
//L is the Lset
//pv is the pivot
function sizeOfL(P, L, pv) {
  //exceptional case where the Lset is the whole polygone
  //and thus is the size is equal to the number of vertices

  //L[0][0] is the edge hit by the right tangeant
  //L[1][0] is the edge hit by the left tangeant
  if (L[0][0] == -2) {
    return P.vertices.length;
  }
  if (L[0][0] == -1) {
    if (L[1][0] == -1) {
      //case where none of the support lines are passing through the polygone P
      return 0;
    }

    let nb = 0;
    //case where the left support line is passing through the polygone P and the right one is not
    if (pv > L[1][0]) {
      //case where the index of the pivot is greater than the index of the edge hit by the left tangeant
      //and thus all the vertices with higher index than the pivot and lower index than the edge hit by the left tangeant are in the Lset
      nb = P.vertices.length - (pv + 1) + L[1][0] + 1;
    } else {
      //case where the index of the pivot is lower than the index of the edge hit by the left tangeant
      nb = L[1][0] - pv + 1;
    }
    // +1 in both cases because there is only one intersection point between the tangeants and the edges

    if (nb < 0) {
      throw new Error("nb < 0");
    }
    return (nb + P.vertices.length) % P.vertices.length;
  } else {
    //same reasoning as above
    if (L[1][0] == -1) {
      let nb = 0;
      if (pv > L[0][0]) {
        nb = pv - L[0][0] + 1;
      } else {
        nb = P.vertices.length - (L[0][0] + 1);
        nb += pv + 1;
      }

      return nb;
    }

    let nb = 0;
    if (L[0][0] <= L[1][0]) {
      nb = L[1][0] - L[0][0] + 2;
      return nb;
    }

    nb = P.vertices.length - L[0][0] + 2 + L[1][0];
    if (nb < 0) {
      throw new Error("nb < 0");
    }
    return nb;
  }
}

//function that returns the ith element of the Lset

function enumerateL(L, P, i, pv, size) {
  if (i >= size) {
    throw new Error("i>=size");
  }

  //L[0][0] is the edge hit by the right tangeant
  //L[1][0] is the edge hit by the left tangeant
  //L[0][1] is the intersection point between the right tangeant and the edge hit by the right tangeant
  //L[1][1] is the intersection point between the left tangeant and the edge hit by the left tangeant

  let indexOfV;
  if (L[0][0] == -2) {
    //exceptional case where the Lset is the whole polygone
    indexOfV = (i + pv) % P.vertices.length;
    return P.vertices[indexOfV];
  }
  if (L[0][0] == -1) {
    //case where the right tangeant does not pass through the polygone P
    if (L[1][0] == -1) {
      throw new Error("L[1][0] == -1 should not happen");
    }
    //return the last element of the Lset which is the intersection point between the left tangeant and the edge hit by the left tangeant
    if (i == size - 1) {
      return L[1][1];
    }

    //use the pivot + 1 as offset to get the ith element of the Lset
    indexOfV = (pv + 1 + i) % P.vertices.length;


    return P.vertices[indexOfV];
  } else {

    if (L[1][0] == -1) {
      //case where the left tangeant does not pass through the polygone P
      if (i == 0) {
        return L[0][1];
      }
      //use the index of the edge hit by the right tangeant as offset to get the ith element of the Lset
      indexOfV = (L[0][0] + i) % P.vertices.length;
      return P.vertices[indexOfV];
    }
    //case where both tangeants pass through the polygone P
    if (i == 0) {
      return L[0][1];
    }
    if (i == size - 1) {
      return L[1][1];
    }
    //use the index of the edge hit by the right tangeant as offset to get the ith element of the Lset

    indexOfV = (i + L[0][0]) % P.vertices.length;
    return P.vertices[indexOfV];
  }
}
//function that returns the index of the edge hit by the tangeant in the quadrilateral AYBX
function calculateInterSectionAXBY(A, B, X, Y, segmentViVi1) {

  let segmentAX = new Segment(A, X);
  let segmentAY = new Segment(A, Y);
  let segmentXB = new Segment(X, B);
  let segmentYB = new Segment(Y, B);
  let listSegments = [segmentAX, segmentAY, segmentXB, segmentYB];
  let lineViVi1 = segmentViVi1.getLine();
  let possiblePoints = [];
  //IGL is not used here because of the overhead to check just 4 edges
  // iterate over the four edges of the quadrilateral
  for (let i = 0; i < listSegments.length; i++) {
    let segment = listSegments[i];
    let line = segment.getLine();
    try {
      let point = getIntersectionPoint(line, lineViVi1);
      //point.draw(255, 255, 0);
      if (segment.isBetweenAB(point)) {
        possiblePoints.push(point);
      }
    } catch (e) {
      console.log(e.message);
    }
  }

  if (possiblePoints.length != 2) {
    throw new Error("A line should intersect only two times with a quadrilateral");
  }


  let point1 = possiblePoints[0];
  let point2 = possiblePoints[1];
  let segv1P = new Segment(segmentViVi1.a, point1);
  if (segv1P.isBetweenAB(segmentViVi1.b)) {
    //        F      G
    return [point1, point2];
  }
  //        G      F
  return [point2, point1];
}
//function that check is point U is on the left of the segment AB which means if U is on X or Y
function isOnx(U, A, B) {
  let segAB = new Segment(A, B);
  if (segAB.isLeft(U)) {
    return false;
  }
  return true;
}
function pointTSmallerThanPointU(pointU, pointT, A, B, X, Y) {
  let segAB = new Segment(A, B);
  if (segAB.isLeft(pointT)) {
    if (segAB.isLeft(pointU)) {
      // CASE  U T ON AYB
      let segXY = new Segment(X, Y);
      if (segXY.isRight(pointT)) {
        if (segXY.isLeft(pointU)) {
          // CASE A U Y T B    
          return true;
        } else {
          // CASE A Y T U B OR A Y U T B
          let segYT = new Segment(Y, pointT);
          if (segYT.isBetweenAB(pointU)) {
            //CASE A Y U T B 
            return true;
          } else {
            //CASE A Y T U B 
            return false;
          }
        }
      } else {
        if (segXY.isRight(pointU)) {
          // CASE A T Y U B 
          return false;
        } else {
          let segAT = new Segment(A, pointT);
          if (segAT.isBetweenAB(pointU)) {
            // CASE A U T Y B 
            return true;
          } else {
            // CASE A T U Y B 
            return false;
          }
        }
      }
    } else {
      // CASE  T ON AYB AND U ON AXB
      return false;
    }
  } else {
    if (segAB.isLeft(pointU)) {
      // CASE  U ON AYB AND T ON AXB 
      return false;
    } else {
      // CASE  U T ON AXB
      let segXY = new Segment(X, Y);
      if (segXY.isRight(pointT)) {
        if (segXY.isLeft(pointU)) {
          //CASE A U X T B 
          return true;
        } else {
          let segXT = new Segment(X, pointT);
          if (segXT.isBetweenAB(pointU)) {
            //CASE A X U T B 
            return true;
          } else {
            //CASE A X T U B 
            return false;
          }
        }
      } else {
        if (segXY.isRight(pointU)) {
          // CASE A T X U B 
          return false;
        } else {
          let segAT = new Segment(A, pointT);
          if (segAT.isBetweenAB(pointU)) {
            // CASE A U T X B 
            return true;
          } else {
            // CASE A T U X B 
            return false;
          }
        }
      }
    }
  }
}

function recursionOnLvLw(
  LV,
  LW,
  P,
  Q,
  pvP,
  pvQ,
  LUBoundV,
  LUBoundW,
  AYBXA,
  A,
  B,
  X,
  Y,
  origSizeV,
  origSizeW
) {

  //get the size of the Lset
  sizeV = LUBoundV[1] - LUBoundV[0] + 1 + 2;
  sizeW = LUBoundW[1] - LUBoundW[0] + 1 + 2;
  //check if the size of the Lset is smaller than 6
  if (sizeV < 6 || sizeW < 6) {
    return [LUBoundV, LUBoundW];
  }

  //get the middle of the Lset
  let i = Math.floor((LUBoundV[0] + LUBoundV[1]) / 2);
  let j = Math.floor((LUBoundW[0] + LUBoundW[1]) / 2);

  let vi = enumerateL(LV, P, i, pvP, origSizeV);
  let vi1 = enumerateL(LV, P, i + 1, pvP, origSizeV);
  let wj = enumerateL(LW, Q, j, pvQ, origSizeW);
  let wj1 = enumerateL(LW, Q, j + 1, pvQ, origSizeW);
  let segViVi1 = new Segment(vi, vi1);
  let segWjWj1 = new Segment(wj, wj1);

  let FG = calculateInterSectionAXBY(A, B, X, Y, segViVi1);
  let F = FG[1];
  let G = FG[0];
  let EH = calculateInterSectionAXBY(A, B, X, Y, segWjWj1);
  let E = EH[0];
  let H = EH[1];

  



  // each case of the recursion of the function  decribed in the paper of  Intersection of Convex Objects in Two and Three 
  //Dimensions by B. CHAZELLE  and D. P. DOBKIN 
  ///////////////////CASE 1 //////////////////////////

  // if G and F are on x
  if (isOnx(F, A, B) && isOnx(G, A, B)) {
    //LV becomes [v0, v1, ..., vi,vi+1,vn]
    LUBoundV[1] = i + 1;
  } else {
    // if G and F lie on y
    if (!isOnx(F, A, B) && !isOnx(G, A, B)) {
      //LV becomes [v0, vi, vi+1, ..., vn]
      LUBoundV[0] = i;
    }
  }
  // if E and H are on x
  if (isOnx(E, A, B) && isOnx(H, A, B)) {
    //LW becomes [w0, w1, ..., wj,wj+1,wn]
    LUBoundW[0] = j;
  } else {
    // if E and H lie on y
    if (!isOnx(E, A, B) && !isOnx(H, A, B)) {
      //LW becomes [w0, wj, wj+1, ..., wn]
      LUBoundW[1] = j + 1;
    }
  }

  /////////////////////CASE 2 //////////////////////////
  // if F and E are on x and G and H are on y
  if (isOnx(F, A, B) && isOnx(E, A, B) && !isOnx(G, A, B) && !isOnx(H, A, B)) {

    // if F < E and G < H
    if (
      pointTSmallerThanPointU(F, E, A, B, X, Y) &&
      pointTSmallerThanPointU(G, H, A, B, X, Y)
    ) {
      //case no collision
      return [false];
    }

    /////////////////////CASE 3 //////////////////////////
    // if G < H and F < E
    if (
      pointTSmallerThanPointU(H, G, A, B, X, Y) &&
      pointTSmallerThanPointU(F, E, A, B, X, Y)
    ) {
      let segGF = new Segment(G, F);
      let segEH = new Segment(E, H);
      //get the intersection of GF and EH
      let I = getIntersectionPoint(segGF.getLine(), segEH.getLine());
      let segGI = new Segment(G, I);
      let lineGI = segGI.getLine();
      let segHI = new Segment(H, I);
      let lineHI = segHI.getLine();
      //check if vi is on the segment GI.
      if (segGI.isBetweenAB(vi) && lineGI.isOnTheLine(vi)) {
        LUBoundV[0] = i;
      }
      //check if wj1 is on the segment HI.
      if (segHI.isBetweenAB(wj1) && lineHI.isOnTheLine(wj1)) {
        LUBoundW[1] = j + 1;
      }
    }
    //if G < H and F > E
    if (
      pointTSmallerThanPointU(G, H, A, B, X, Y) &&
      pointTSmallerThanPointU(E, F, A, B, X, Y)
    ) {
      let segGF = new Segment(G, F);
      let segEH = new Segment(E, H);
      //get the intersection of GF and EH 
      let I = getIntersectionPoint(segGF.getLine(), segEH.getLine());
      let segFI = new Segment(F, I);
      let lineFI = segFI.getLine();
      let segEI = new Segment(E, I);
      let lineEI = segEI.getLine();
      //check if vi1 is on the segment FI.
      if (segFI.isBetweenAB(vi1) && lineFI.isOnTheLine(vi1)) {
        LUBoundV[1] = i + 1;
      }
      //check if wj is on the segment EI.
      if (segEI.isBetweenAB(wj) && lineEI.isOnTheLine(wj)) {
        LUBoundW[0] = j;
      }
    }
    /////////////////////CASE 4 //////////////////////////
    let segAvi = new Segment(A, vi);
    let segBwj = new Segment(B, wj);
    //if A vi intersects with B wj
    if (segAvi.intersectWithSegment(segBwj)) {
      //there is a collision
      let R = getIntersectionPoint(segAvi.getLine(), segBwj.getLine());
      textSize(24);
      fill(0);
      text("R", R.x - 10, R.y - 15);
      R.draw(255, 0, 0);
      return [true];
    }
    /////////////////////CASE 5 //////////////////////////
    let segmentAvi = new Segment(A, vi);
    let segmentHE = new Segment(H, E);
    // R is the intersection of the segment Avi and the segment HE
    let R = getIntersectionPoint(segmentAvi.getLine(), segmentHE.getLine());
    let segmentER = new Segment(E, R);
    if (segmentER.isBetweenAB(wj)) {
      LUBoundV[1] = i + 1;
      LUBoundW[1] = j + 1;
    } else {
      LUBoundV[0] = i;
      LUBoundW[0] = j;
    }
  }

  return recursionOnLvLw(
    LV,
    LW,
    P,
    Q,
    pvP,
    pvQ,
    LUBoundV,
    LUBoundW,
    AYBXA,
    A,
    B,
    X,
    Y,
    origSizeV,
    origSizeW
  );
}

//Class used to calculate the orientation determinant
class Matrix2X2 {
  constructor(a, b, c, d) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
  }
  determinant() {
    return this.a * this.d - this.c * this.b;
  }
}

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  copy() {
    return new Point(this.x, this.y);
  }
  //check if two points are the same with a epsilon margin
  isSame(point) {
    let x = Math.abs(this.x - point.x);
    let y = Math.abs(this.y - point.y);
    return x < epsilon && y < epsilon;
  }
  draw(r, g, b) {
    fill(r, g, b);
    ellipse(this.x, this.y, DOTSIZE, DOTSIZE);
  }
  //calculate the distance between two points
  distance(point) {
    return Math.sqrt(
      Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2)
    );
  }
}
class Line {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  draw() {
    stroke(0);
    strokeWeight(2);
    let limit = 10000;
    let p1 = new Point(-limit, (-this.c - this.a * -limit) / this.b);
    let p2 = new Point(limit, (-this.c - this.a * limit) / this.b);
    line(p1.x, p1.y, p2.x, p2.y);
  }
  draw(r, g, b) {
    stroke(r, g, b);
    strokeWeight(2);
    let limit = 10000;
    let p1 = new Point(-limit, (-this.c - this.a * -limit) / this.b);
    let p2 = new Point(limit, (-this.c - this.a * limit) / this.b);
    line(p1.x, p1.y, p2.x, p2.y);
    stroke(0, 0, 0);
  }
  //check if two points are on the same side of the line
  side(p, q) {
    return (
      (this.a * p.x + this.b * p.y + this.c) *
      (this.a * q.x + this.b * q.y + this.c)
    );
  }
  //check if a point is on the line with a epsilon margin
  isOnTheLine(p) {
    let evalutation = this.a * p.x + this.b * p.y + this.c;
    return evalutation < epsilon && evalutation > -epsilon;
  }
  //calculate the distance between a point and a line
  distance(p) {
    return (
      Math.abs(this.a * p.x + this.b * p.y + this.c) /
      Math.sqrt(this.a * this.a + this.b * this.b)
    );
  }
}
// calculate the distance of pi to the line L multiplied L.side(pi, p)
function h(pi, L, p) {
  let s = L.side(pi, p);
  if (s == 0) {
    return 0;
  }
  let absS = Math.abs(s);

  return L.distance(pi) * (s / absS);
}

class Segment {
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }
  copy() {
    return new Segment(this.x, this.y);
  }
  draw() {
    stroke(0);
    strokeWeight(2);
    line(this.a.x, this.a.y, this.b.x, this.b.y);
  }
  draw(r, g, b) {
    stroke(r, g, b);
    strokeWeight(2);
    line(this.a.x, this.a.y, this.b.x, this.b.y);
    stroke(0, 0, 0);
  }
  orientation(pointA) {
    return orientationDET(this, pointA);
  }
  isLeft(pointA) {
    return orientationDET(this, pointA) < 0;
  }
  isRight(pointA) {
    return orientationDET(this, pointA) > 0;
  }
  //turn the segment into a line
  getLine() {
    if (this.a.x < this.b.x) {
      let a = this.b.y - this.a.y;
      let b = this.a.x - this.b.x;
      let c = this.b.x * this.a.y - this.a.x * this.b.y;
      return new Line(a, b, c);
    } else {
      let a = this.a.y - this.b.y;
      let b = this.b.x - this.a.x;
      let c = this.a.x * this.b.y - this.b.x * this.a.y;
      return new Line(a, b, c);
    }
  }
  //check if a point is inside the bounding box made by the extremities of the segment
  isBetweenAB(pointA) {
    let minX = Math.min(this.a.x, this.b.x) - epsilon;
    let maxX = Math.max(this.a.x, this.b.x) + epsilon;
    let minY = Math.min(this.a.y, this.b.y) - epsilon;
    let maxY = Math.max(this.a.y, this.b.y) + epsilon;
    return (
      pointA.x >= minX &&
      pointA.x <= maxX &&
      pointA.y >= minY &&
      pointA.y <= maxY
    );
  }
  //check if two segments intersect
  intersectWithSegment(segment) {
    let det1 = orientationDET(this, segment.a);
    let det2 = orientationDET(this, segment.b);
    let det3 = orientationDET(segment, this.a);
    let det4 = orientationDET(segment, this.b);
    if (det1 * det2 < 0 && det3 * det4 < 0) {
      return true;
    }
    return false;
  }
}
class Triangle {
  constructor(pointA, pointB, pointC) {
    this.edges = [];
    //determine if pointC is on the left or right of the vector(A,B)
    var det = orientationDET(new Segment(pointA, pointB), pointC);
    //connect anticlockwise depending on the case
    if (det < 0) {
      this.edges.push(new Segment(pointA, pointB));
      this.edges.push(new Segment(pointB, pointC));
      this.edges.push(new Segment(pointC, pointA));
    } else {
      this.edges.push(new Segment(pointB, pointA));
      this.edges.push(new Segment(pointA, pointC));
      this.edges.push(new Segment(pointC, pointB));
    }
  }
  draw() {
    for (let edge of this.edges) {
      edge.draw();
    }
  }
  isDotInside(point) {
    for (let edge of this.edges) {
      if (edge.isRight(point)) {
        return false;
      }
    }
    return true;
  }
}

class ConvexHull {
  //constructor uses graham scan to know the extrem dots.
  //then they are all connected to make a polygone
  constructor(arrayOfpoints) {
    this.vertices = [];
    //name of the center of mass
    this.cmName = "";
    let cpArrPts = [];
    //copy the dots to not have a impact on the rest of the code
    for (let point of arrayOfpoints) {
      cpArrPts.push(point.copy());
    }

    //find the most left dot
    cpArrPts.sort(comparePoints);
    ANCHOR = cpArrPts[0]; //set anchor for comparison
    //sort the dots radialy with as anchor the most left dot
    cpArrPts.sort(comparePointsAngle);
    let listOfIndex = [0, 1]; //the stack

    let tmpSegment = new Segment(cpArrPts[0], cpArrPts[1]);
    let i = 2;
    //graham scan
    while (i < cpArrPts.length) {
      let size = listOfIndex.length;
      tmpSegment.a = cpArrPts[listOfIndex[size - 2]];
      tmpSegment.b = cpArrPts[listOfIndex[size - 1]];
      var det = tmpSegment.orientation(cpArrPts[i]);
      //check if it is a left turn
      if (det <= 0) {
        listOfIndex.push(i);
        i++;
      } else {
        //if not, pop until it becomes a left turn
        while (det > 0) {
          listOfIndex.pop();
          size = listOfIndex.length;
          tmpSegment.a = cpArrPts[listOfIndex[size - 2]];
          tmpSegment.b = cpArrPts[listOfIndex[size - 1]];
          det = tmpSegment.orientation(cpArrPts[i]);
        }
      }
    }
    //remove all unnecessary points
    for (let i of listOfIndex) {
      this.vertices.push(cpArrPts[i]);
    }
    i = 1;
    this.edges = [];
    let size = listOfIndex.length;
    while (i < size) {
      this.edges.push(
        new Segment(cpArrPts[listOfIndex[i - 1]], cpArrPts[listOfIndex[i]])
      );
      i++;
    } //connect the last dot to the first one
    this.edges.push(
      new Segment(cpArrPts[listOfIndex[size - 1]], cpArrPts[listOfIndex[0]])
    );

    this.area = 0;
    this.centerx = 0;
    this.centery = 0;
    //calculate the center of mass by doing the ponderated center of mass of the triangles of the polygone depending their area.
    for (let i = 1; i < this.vertices.length - 1; i++) {
      let a = this.vertices[0];
      let b = this.vertices[i];
      let c = this.vertices[i + 1];
      this.area += Math.abs(orientationDET(new Segment(a, b), c));
      this.centerx +=
        (a.x + b.x + c.x) * Math.abs(orientationDET(new Segment(a, b), c)) / 3;
      this.centery +=
        (a.y + b.y + c.y) * Math.abs(orientationDET(new Segment(a, b), c)) / 3;
    }
    this.centerx /= this.area;
    this.centery /= this.area;
    this.centerMass = new Point(this.centerx, this.centery);

    this.speedx = 0;
    this.speedy = 0;
    //define the bounding box to know if the polygone is colliding with the border
    this.minX = 100000000000000000;
    this.minY = 100000000000000000;
    this.maxX = -100000000000000000;
    this.maxY = -100000000000000000;
    for (let vertice of this.vertices) {
      this.minX = Math.min(this.minX, vertice.x);
      this.minY = Math.min(this.minY, vertice.y);
      this.maxX = Math.max(this.maxX, vertice.x);
      this.maxY = Math.max(this.maxY, vertice.y);
    }
  }
  setSpeed(x, y) {
    this.speedx = x;
    this.speedy = y;
  }

  move() {
    let x = this.speedx;
    let y = this.speedy;
    for (let vertice of this.vertices) {
      vertice.x += x;
      vertice.y += y;
    }

    this.centerMass.x += x;
    this.centerMass.y += y;
    this.minX += x;
    this.minY += y;
    this.maxX += x;
    this.maxY += y;
    this.isCollidingBorder();
  }
  iscollideX() {
    if (this.minX < 0 || this.maxX > maxX) {
      this.speedx = -this.speedx;
    }
  }
  iscollideY() {
    if (this.minY < 0 || this.maxY > maxY) {
      this.speedy = -this.speedy;
    }
  }
  isCollidingBorder() {
    this.iscollideX();
    this.iscollideY();
  }

  //Algorithm to find if the polygone is colliding with the line L.
  // if it is the case, it returns the indexes of the edges that are intersecting with the line
  //if not, it returns an empty array
  // L is a line
  //piv is point of the polygone which cannot be on the line and is used to determined which side of the
  //line other vertices are.
  IGL(L, piv) {


    //offset function to make the array circular
    const offsetF = (i) => {
      return (i + piv) % this.vertices.length;
    };


    //find the index of the point that has the smallest h value
    //this is done in linear time because I did not succeed to make fibonacci search work 100% of the time
    let minHvalue = 100000000000000000;
    let minindex = -1;
    for (let i = 0; i < this.vertices.length; i++) {
      let v = this.vertices[offsetF(i)];
      let hValue = h(v, L, this.vertices[piv]);
      if (hValue < minHvalue) {
        minHvalue = hValue;
        minindex = i;
      }
    }

    // mean the line is not intersecting the polygone
    if (minHvalue > -epsilon) {
      return [];
    }
    const cmp1 = (i) => {
      const v = this.vertices[offsetF(i)];
      return h(v, L, this.vertices[piv]) > 0;
    };
    //binary search to find the first transition of positive to negative between the vertice 0 and the vertice minindex
    let indexInt1 = binarySearch(0, min(this.vertices.length, minindex + 1), cmp1
    );

    const cmp2 = (i) => {
      return !cmp1(i);
    };
    //find the second transition of negative to positive between the vertice 0 and the vertice minindex
    let indexInt2 = binarySearch(minindex, this.vertices.length - 1, cmp2);
    //return the indexes of the edges that are intersecting with the line
    // in a increasing order
    if (offsetF(indexInt1) < offsetF(indexInt2)) {
      return [offsetF(indexInt1), offsetF(indexInt2)];
    } else {
      return [offsetF(indexInt2), offsetF(indexInt1)];
    }
  }
  IGG(Q) {
    let tangP, tan1P, tan2P;
    let indexTan1P, indexTan2P;
    let indexTan1Q, indexTan2Q;
    let tangQ, tan1Q, tan2Q;
    let x = this.vertices[0];
    let y = this.vertices[0];
    let keepGoing = true;
    let pvP;
    let pvQ;
    let boolOtherCalculation = true;
    let toDrawQ, toDrawP;
    for (pvP = 0; pvP < this.vertices.length && keepGoing && boolOtherCalculation; pvP++) {
      tangP = this.pencil(Q, pvP, 0);
      //if the two polygones intersect, return true
      if (tangP[0] == null) {
        return true;
      }

      // get the tangents of the polygone P and  the indexes of the vertices
      // on Q of  the tangents
      tan1P = tangP[0][0];
      tan2P = tangP[1][0];
      toDrawP = tangP[2]; //points and segments to draw for visualisation
      indexTan1P = tangP[0][1];
      indexTan2P = tangP[1][1];


      //This is not necessary but it is used to avoid certain edge cases
      //we check for the furthest point of Q from the point pvP of P
      // and use it as a pivot to start the search of the tangents
      //this adds a complexity of O(Log(n)) to the algorithm where n is the number of vertices of Q
      let segmentpvQ = new Segment(this.vertices[pvP], Q.centerMass);
      let indexes = Q.IGL(segmentpvQ.getLine(), 0);
      let vertindex = [];
      for (let i = 0; i < indexes.length; i++) {
        let index = indexes[i];
        let index2 = (index + 1) % Q.vertices.length;
        vertindex.push(index);
        vertindex.push(index2);
      }
      let indexFurthest = -1;
      let minDist = 0;
      for (let i = 0; i < vertindex.length; i++) {
        let index = vertindex[i];
        let dist = this.vertices[pvP].distance(Q.vertices[index]);
        if (dist > minDist) {
          minDist = dist;
          indexFurthest = index;
        }
      }


      for (pvQ = indexFurthest; pvQ < Q.vertices.length && boolOtherCalculation; pvQ++) {
        // avoid the case where the pivot is the same as the tangent
        //because on the tangeant of P will be parallel to the tangeant of Q.
        //This needs to be avoided the two pencils needs  to form a quadrilateral
        if (pvQ == indexTan2P || pvQ == indexTan1P) {
          continue;
        }

        tangQ = Q.pencil(this, pvQ, pvP);
        if (tangQ[0] == null) {
          return true;
        }
        tan1Q = tangQ[0][0];
        tan2Q = tangQ[1][0];
        toDrawQ = tangQ[2];
        x = getIntersectionPoint(tan1P, tan2Q);
        y = getIntersectionPoint(tan2P, tan1Q);
        //check if the two pencil  form a quadrilateral
        if (!(x.isSame(y) || x.isSame(this.vertices[pvP]) || y.isSame(this.vertices[pvP]) || x.isSame(Q.vertices[pvQ]) || y.isSame(Q.vertices[pvQ]))) {
          keepGoing = false;
          pvP--;
          break;
          
        }
      }
    }

    //draw the visualisation for the segment AB
    if (drawAB) {
      let indexes_q, a_p, b_p, segab_p;
      indexes_q = toDrawP[0];
      a_p = toDrawP[1];
      b_p = toDrawP[2];
      segab_p = toDrawP[3];
      textSize(12);
      fill(255, 0, 0);
      text("a", a_p.x - 10, a_p.y - 15);
      text("b", b_p.x - 10, b_p.y - 15);
      a_p.draw(255, 0, 0);
      b_p.draw(255, 0, 0);
      segab_p.draw(255, 0, 0);
      for (let i = 0; i < indexes_q.length; i++) {
        let k = indexes_q[i];
        Q.edges[k].draw(255, 0, 0);
      }
      let indexes_p, a_q, b_q, segab_q;
      indexes_p = toDrawQ[0];
      a_q = toDrawQ[1];
      b_q = toDrawQ[2];
      segab_q = toDrawQ[3];
      textSize(12);
      fill(255, 0, 0);
      text("a", a_q.x - 10, a_q.y - 15);
      text("b", b_q.x - 10, b_q.y - 15);
      a_q.draw(255, 0, 0);
      b_q.draw(255, 0, 0);
      segab_q.draw(255, 0, 0);
      for (let i = 0; i < indexes_p.length; i++) {
        let k = indexes_p[i];
        this.edges[k].draw(255, 0, 0);
      }

    }
    //draw the visualisation for the pencils
    if (drawTangeant) {
      let indexTan1P = tangP[0][1];
      let indexTan2P = tangP[1][1];
      //calculate a point at "infinity" to draw the tangeants such that
      // the line of  the tangeants  begins at the pivots and goes to "infinity"
      let infX = (Q.vertices[indexTan1P].x - this.vertices[pvP].x) * 100000;
      infX += this.vertices[pvP].x;
      let infY = (Q.vertices[indexTan1P].y - this.vertices[pvP].y) * 100000;
      infY += this.vertices[pvP].y;
      let infPoint = new Point(infX, infY);
      let segmentTan1P = new Segment(this.vertices[pvP], infPoint);

      infX = (Q.vertices[indexTan2P].x - this.vertices[pvP].x) * 100000;
      infX += this.vertices[pvP].x;
      infY = (Q.vertices[indexTan2P].y - this.vertices[pvP].y) * 100000;
      infY += this.vertices[pvP].y;
      infPoint = new Point(infX, infY);
      let segmentTan2P = new Segment(this.vertices[pvP], infPoint);
      segmentTan1P.draw(0, 0, 255);
      segmentTan2P.draw(255, 0, 100);


      let indexTan1Q = tangQ[0][1];
      let indexTan2Q = tangQ[1][1];
      infX = (this.vertices[indexTan1Q].x - Q.vertices[pvQ].x) * 100000;
      infX += Q.vertices[pvQ].x;
      infY = (this.vertices[indexTan1Q].y - Q.vertices[pvQ].y) * 100000;
      infY += Q.vertices[pvQ].y;
      infPoint = new Point(infX, infY);
      let segmentTan1Q = new Segment(Q.vertices[pvQ], infPoint);
      infX = (this.vertices[indexTan2Q].x - Q.vertices[pvQ].x) * 100000;
      infX += Q.vertices[pvQ].x;
      infY = (this.vertices[indexTan2Q].y - Q.vertices[pvQ].y) * 100000;
      infY += Q.vertices[pvQ].y;
      infPoint = new Point(infX, infY);
      let segmentTan2Q = new Segment(Q.vertices[pvQ], infPoint);
      segmentTan1Q.draw(0, 255, 0);
      segmentTan2Q.draw(255, 255, 100);
    }

    // get the two  edges where the two pencils are intersecting to know the size of the Lset
    let LV = this.getLset(tangP, Q, pvP);
    let LW = Q.getLset(tangQ, this, pvQ);
    let sizeLV = sizeOfL(this, LV, pvP);
    let sizeLW = sizeOfL(Q, LW, pvQ);
    //draw the visualisation for the Lset
    if (drawViWi) {
      for (let i = 0; i < sizeLV; i++) {
        let v = enumerateL(LV, this, i, pvP, sizeLV);
        v.draw(0, 0, 0);
        textSize(12);
        fill(255, 0, 127);
        text("v" + str(i + 1), v.x - 5, v.y - 5);
      }
      fill(0);

      for (let i = 0; i < sizeLW; i++) {
        let v = enumerateL(LW, Q, i, pvQ, sizeLW);
        v.draw(0, 0, 0);
        textSize(12);
        fill(255, 0, 127);
        text("w" + str(i + 1), v.x - 10, v.y - 15);
      }
      fill(0);
    }

    let a = this.vertices[pvP];
    let b = Q.vertices[pvQ];
    //draw the quadrilateral AXBY formed by the two pencils
    if (drawAXBY) {
      textSize(24);
      fill(0, 100, 255);
      text("A", a.x - 10, a.y - 15);
      fill(255, 100, 0);
      text("B", b.x - 10, b.y - 15);

      fill(0, 200, 0);
      text("X", x.x - 10, x.y - 15);
      fill(200, 0, 0);
      text("Y", y.x - 10, y.y - 15);
      x.draw(255, 0, 255);
      y.draw(255, 255, 255);
    }
    //define the convex hull of the quadrilateral AXBY
    let AYBXA = new ConvexHull([a, y, b, x]);
    // reduce the size of the Lset to the size of the Lset of the quadrilateral AXBY
    let LVW = recursionOnLvLw(LV, LW, this, Q, pvP, pvQ, [1, sizeLV - 2], [1, sizeLW - 2], AYBXA, a, b, x, y, sizeLV, sizeLW
    );
    if (LVW.length == 1) {
      return LVW[0];
    }

    textSize(10);

    let lsegV = [];
    let lsegW = [];
    //create the edges of the L sets to check if they intersect
    if (sizeLV >= 2) {
      //create the edges of the Lset
      lsegV.push(
        new Segment(
          enumerateL(LV, this, 0, pvP, sizeLV),
          enumerateL(LV, this, LVW[0][0], pvP, sizeLV)
        )
      );
      //iterate over the reduced Lset
      for (let i = LVW[0][0]; i < LVW[0][1]; i++) {
        if (drawLSet) {
          //draw the visualisation representation the reduced Lset
          let v = enumerateL(LV, this, i, pvP, sizeLV);
          v.draw(255, 0, 226);
          text("v", v.x - 10, v.y - 15);
        }
        lsegV.push(
          new Segment(
            enumerateL(LV, this, i, pvP, sizeLV),
            enumerateL(LV, this, i + 1, pvP, sizeLV)
          )
        );
      }
      lsegV.push(
        new Segment(
          enumerateL(LV, this, LVW[0][1], pvP, sizeLV),
          enumerateL(LV, this, sizeLV - 1, pvP, sizeLV)
        )
      );
      if (drawLSet) {
        //draw the visualisation representation the reduced Lset

        let v1 = enumerateL(LV, this, 0, pvP, sizeLV);
        text("v1", v1.x - 10, v1.y - 15);
        v1.draw(255, 0, 226);
        let vn = enumerateL(LV, this, sizeLV - 1, pvP, sizeLV);
        vn.draw(255, 0, 226);
        text("vn", vn.x - 10, vn.y - 15);
      }
    }

    //same as above but for the Lset of Q
    if (sizeLW >= 2) {
      lsegW.push(
        new Segment(
          enumerateL(LW, Q, 0, pvQ, sizeLW),
          enumerateL(LW, Q, LVW[1][0], pvQ, sizeLW)
        )
      );
      for (let i = LVW[1][0]; i < LVW[1][1]; i++) {
        lsegW.push(
          new Segment(
            enumerateL(LW, Q, i, pvQ, sizeLW),
            enumerateL(LW, Q, i + 1, pvQ, sizeLW)
          )
        );
        if (drawLSet) {
          let v = enumerateL(LW, Q, i, pvQ, sizeLW);
          text("w" + str(i + 1), v.x - 10, v.y - 15);
          v.draw(255, 0, 226);
        }
      }
      lsegW.push(
        new Segment(
          enumerateL(LW, Q, LVW[1][1], pvQ, sizeLW),
          enumerateL(LW, Q, sizeLW - 1, pvQ, sizeLW)
        )
      );
      if (drawLSet) {
        let w1 = enumerateL(LW, Q, 0, pvQ, sizeLW);
        w1.draw(255, 0, 226);
        text("w1", w1.x - 10, w1.y - 15);
        let wn = enumerateL(LW, Q, sizeLW - 1, pvQ, sizeLW);
        wn.draw(255, 0, 226);
        text("wn", wn.x - 10, wn.y - 15);
      }
    }
    if (drawLSet) {
      //draw the visualisation representation edges of the Lset
      for (let i = 0; i < lsegV.length; i++) {
        lsegV[i].draw(255, 255, 0);
      }
      for (let i = 0; i < lsegW.length; i++) {
        lsegW[i].draw(0, 255, 255);
      }
    }

    if (sizeLV > 0 && sizeLW > 0) {
      //check if the two Lsets intersect by checking if one element of the Lset of P intersects with one element of the Lset of Q
      for (let i = 0; i < lsegV.length; i++) {
        for (let j = 0; j < lsegW.length; j++) {
          let segV = lsegV[i];
          let segW = lsegW[j];
          if (segV.intersectWithSegment(segW)) {
            return true;
          }
        }
      }
      //a better could have been used to check if the two Lsets intersect like sweep line algorithm


    }
    return false;
  }

  draw() {
    for (let edge of this.edges) {
      edge.draw();
    }
    //draw the vertices of the polygone
    //for (let vertice of this.vertices) {
    //  vertice.draw(0, 255, 0);
    //  textSize(12);
    //  fill(0);
    //  //text(this.vertices.indexOf(vertice) + 1, vertice.x + 10, vertice.y);
    //}
    this.centerMass.draw(255, 0, 0);
    textSize(12);
    fill(0);
    text(this.cmName, this.centerMass.x + 10, this.centerMass.y);
  }

  isInsideConvex(pointA) {
    // make cmp function for the generic binary search
    const cmp = (i) => {
      const segmentBeingTested = new Segment(
        this.vertices[0],
        this.vertices[i]
      );
      return segmentBeingTested.isLeft(pointA);
    };
    let index;
    index = binarySearch(1, this.vertices.length - 1, cmp);

    if (index > 0) {
      // case where the point is on the segment between the first and last dot
      if (index == this.vertices.length - 1) {
        let tmpSegment = new Segment(this.vertices[0], this.vertices[index]);
        let minX = Math.min(this.vertices[0].x, this.vertices[index].x);
        let maxX = Math.max(this.vertices[0].x, this.vertices[index].x);
        //return true if the dot is on the segment
        return (
          orientationDET(tmpSegment, pointA) == 0 &&
          pointA.x >= minX &&
          pointA.x <= maxX
        );
      }
      //check if inside the triangle found
      let triangleTested = new Triangle(
        this.vertices[0],
        this.vertices[index],
        this.vertices[index + 1]
      );
      return triangleTested.isDotInside(pointA);
    }
    return false;
  }

  pencil(polygoneQ, piv, pivIGL) {
    //create the segment between the center of mass of the polygone Q and the pivot of the polygone P
    let p1qSegment = new Segment(
      this.vertices[piv].copy(),
      polygoneQ.centerMass.copy()
    );
    let p1qLine = p1qSegment.getLine();

    //get the indexes of the edges that are intersecting with the line
    let indexes = polygoneQ.IGL(p1qLine, pivIGL);
    //get the intersection points
    let lI1 = polygoneQ.edges[indexes[0]].getLine();
    let a = getIntersectionPoint(p1qLine, lI1);
    let lI2 = polygoneQ.edges[indexes[1]].getLine();
    let b = getIntersectionPoint(p1qLine, lI2);
    let segmentab = new Segment(a, b);

    let toDraw = [indexes, a, b, segmentab];
    //if the pivot is on the segment ab,or the center of mass of the polygone Q is inside the polygone P
    if (segmentab.isBetweenAB(this.vertices[piv]) || this.isInsideConvex(polygoneQ.centerMass)) {
      return [null, toDraw];
    } else {
      //checking wich side of the hull we will be working on with indexex[0] 
      if (p1qSegment.isRight(polygoneQ.vertices[indexes[0] + 1])) {

        //working on the lower part of the hull
        //looking for the transition from right to left turn.
        const cmp1 = (i) => {
          let size = polygoneQ.vertices.length;
          const lineBeingTested = new Segment(
            this.vertices[piv],
            polygoneQ.vertices[i]
          );
          return lineBeingTested.isRight(polygoneQ.vertices[(i + 1) % size]);
        };

        //we defined that  indexes[0] is smaller than indexes[1]
        //so we don't need to use  the offset function to  make the array circular
        let tan1 = binarySearch(indexes[0] + 1, indexes[1], cmp1) + 1;
        let lineTan1 = new Segment(
          this.vertices[piv],
          polygoneQ.vertices[tan1]
        ).getLine();

        //make the array circular   and startin from the index indexes[1] + 1
        const offsetFunc2 = (i) => {
          return (i + indexes[1] + 1) % polygoneQ.vertices.length;
        };
        //number of vertices between indexes[1] and the end of the array + indexes[0] and the beginning of the array
        let n = polygoneQ.vertices.length - indexes[1] - 1 + indexes[0] + 1;
        //take the negation of the cmp1 function to find the transition from left to right turn
        const cmp2 = (i) => {
          return !cmp1(offsetFunc2(i));
        };
        //find the transition from left to right turn  
        let tan2 = binarySearch(0, n, cmp2);
        tan2 = offsetFunc2(tan2 + 1);
        let lineTan2 = new Segment(
          this.vertices[piv],
          polygoneQ.vertices[tan2]
        ).getLine();
        //order the tangents such that the first one is the one that is on the right of the segment P1Q
        if (p1qSegment.isRight(polygoneQ.vertices[tan1])) {
          return [[lineTan1, tan1], [lineTan2, tan2], toDraw];
        }
        return [[lineTan2, tan2], [lineTan1, tan1], toDraw];
      } else {
        //working on the upper part of the hull
        //same reasoning as above
        const cmp1 = (i) => {
          let size = polygoneQ.vertices.length;
          const lineBeingTested = new Segment(
            this.vertices[piv],
            polygoneQ.vertices[i]
          );
          return lineBeingTested.isLeft(polygoneQ.vertices[(i + 1) % size]);
        };
        let tan1 = binarySearch(indexes[0] + 1, indexes[1], cmp1) + 1;
        let lineTan1 = new Segment(
          this.vertices[piv],
          polygoneQ.vertices[tan1]
        ).getLine();

        const offsetFunc2 = (i) => {
          return (i + indexes[1] + 1) % polygoneQ.vertices.length;
        };
        let n = polygoneQ.vertices.length - indexes[1] - 1 + indexes[0] + 1;
        const cmp2 = (i) => {
          return !cmp1(offsetFunc2(i));
        };
        let tan2 = binarySearch(0, n, cmp2);
        tan2 = offsetFunc2(tan2 + 1);
        let lineTan2 = new Segment(
          this.vertices[piv],
          polygoneQ.vertices[tan2]
        ).getLine();
        if (p1qSegment.isRight(polygoneQ.vertices[tan1])) {
          return [[lineTan1, tan1], [lineTan2, tan2], toDraw];
        }
        return [[lineTan2, tan2], [lineTan1, tan1], toDraw];
      }
    }
  }
  getLset(tangP, Q, pv) {
    let tan1P = tangP[0][0];
    let tan2P = tangP[1][0];
    let indexTan1P = tangP[0][1];
    let indexTan2P = tangP[1][1];
    let pvm1 = (pv - 1 + this.vertices.length) % this.vertices.length;
    let pvp1 = (pv + 1) % this.vertices.length;
    let acceptableAngle = calculateOrientedAngle(
      this.vertices[pv],
      this.vertices[pvm1],
      this.vertices[pvp1]
    );
    let angleForX = calculateOrientedAngle(
      this.vertices[pv],
      this.vertices[pvm1],
      Q.vertices[indexTan1P]
    );
    let angleForY = calculateOrientedAngle(
      this.vertices[pv],
      this.vertices[pvm1],
      Q.vertices[indexTan2P]
    );
    fill(255, 0, 0);

    let boolV1 = true;
    let boolV2 = true;

    //check if the angle is acceptable
    if ((angleForX > acceptableAngle)) {
      boolV1 = false;
    }
    //check if the angle is acceptable
    if ((angleForY > acceptableAngle)) {
      boolV2 = false;
    }
    if (!boolV1 && !boolV2) {
      let segmentpX = new Segment(
        this.vertices[pv].copy(),
        Q.vertices[indexTan1P]
      );
      let segmentpY = new Segment(
        this.vertices[pv].copy(),
        Q.vertices[indexTan2P]
      );
      //exceptional where the pencil does not pass through the polygone but contains all vertices
      //For example if Q is really big and stands on  the right of the polygone P
      // and the pivot is on the left most point of the polygone P
      if (
        segmentpX.isLeft(this.vertices[pvp1]) &&
        segmentpY.isRight(this.vertices[pvp1]) &&
        segmentpX.isLeft(this.vertices[pvm1]) &&
        segmentpY.isRight(this.vertices[pvm1])
      ) {
        return [
          [-2, null],
          [-2, null],
        ];
      }
    }


    let v1point = null,
      v2point = null;
    let v1 = -1,
      v2 = -1;
    if (boolV1) {
      v1 = this.IGL(tan1P, (pv + 1) % this.vertices.length);
      if (v1.length > 0 && boolV1) {
        //we avoid the edge where the pivot is,because necessarily the pivot is on the edges
        if ((v1[0] + 1) % this.vertices.length == pv || v1[0] == pv) {
          v1 = v1[1];
        } else {
          v1 = v1[0];
        }
        let lineFromV1 = this.edges[v1].getLine();
        //get the intersection point of the edge and the tangeant
        v1point = getIntersectionPoint(lineFromV1, tan1P);
      }
    }
    //same as above
    if (boolV2) {
      v2 = this.IGL(tan2P, (pv + 1) % this.vertices.length);
      if (v2.length > 0) {
        if ((v2[0] + 1) % this.vertices.length == pv || v2[0] == pv) {
          v2 = v2[1];
        } else {
          v2 = v2[0];
        }
        let lineFromV2 = this.edges[v2].getLine();
        v2point = getIntersectionPoint(lineFromV2, tan2P);
      }
    }
    return [
      [v1, v1point],
      [v2, v2point],
    ];
  }
}
function createRandomConvexPolygon2(x, y, width, height, maxPoints) {
  let rPoints = [];
  let stepx = width / maxPoints;
  for (let i = 0; i < maxPoints; i++) {
    let offsetX = i * stepx;
    let offsetY = Math.random() * height;
    if (Math.random() > 0.5) {
      offsetY *= -1;
    }
    rPoints.push(new Point(x + offsetX, y + offsetY));
  }
  return new ConvexHull(rPoints);
}


function draw() {
  // draw BOUNDING BOX

  background(200);
  fill(0, 0, 0);
  noFill();
  rect(0, 0, maxX, maxY);
  for (let convexHull of convexHulls) {
    convexHull.draw();
  }

  let P = convexHulls[0];
  let Q = convexHulls[1];

  //if condition to make the simulation stop without affecting the visualization
  if (STOP) {
    P.IGG(Q)
  }
  else {
    if (pauseWhenCollide && collisionHappened) {
      P.move();
      Q.move();
      collisionHappened = false;
    }
    if (P.IGG(Q)) {
      calculateSpeedAfterCollision(P, Q);
      collisionHappened = true && pauseWhenCollide;
      STOP = true && pauseWhenCollide;
      if (!STOP) {
        P.move();
        Q.move();
      }
    }
    else {
      P.move();
      Q.move();
    }
  }


  fill(0, 255, 0);
  for (let point of points) {
    ellipse(point.x, point.y, DOTSIZE, DOTSIZE);
  }
}



// This Redraws the Canvas when resized
windowResized = function () {
  resizeCanvas(windowWidth, windowHeight);
};
